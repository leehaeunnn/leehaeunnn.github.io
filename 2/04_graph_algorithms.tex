\section{그래프 알고리즘}

\subsection{배경과 목표}
본 모듈은 경로 탐색과 용량 계산을 안정적으로 제공하는 것을 목표로 했습니다.

\subsection{구현 알고리즘}
Dijkstra는 최단 경로 탐색에 사용했습니다.
A*는 휴리스틱 기반 탐색에 적용했습니다.
Floyd–Warshall은 모든 쌍 최단 경로 계산에 사용했습니다.
Maximum Flow는 용량 분석에 활용했습니다.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/2_graph_algos.png}
    \caption{경로 탐색과 용량 분석 개념도}
    \label{fig:graph_algos}
\end{figure}

\paragraph{알고리즘 선택 기준.} 노드 수와 엣지 수에 따라 알고리즘을 선택하고, 실시간 응답이 필요하면 A*를 우선 사용합니다.

\subsection{A* 예시}
\begin{lstlisting}[language=Python]
def a_star_evacuation(graph, start, exits, fire):
    def heuristic(node):
        return min(manhattan(node, ex) for ex in exits)
    def fire_penalty(node):
        d = euclidean(node, fire)
        return 1000 / (d + 1)
    open_set = [(0, start)]
    g = {start: 0}
    f = {start: heuristic(start)}
    while open_set:
        _, cur = heapq.heappop(open_set)
        if cur in exits:
            return reconstruct_path(cur)
        for nb in graph[cur]:
            tg = g[cur] + edge_weight(cur, nb) + fire_penalty(nb)
            if tg < g.get(nb, float('inf')):
                g[nb] = tg
                f[nb] = tg + heuristic(nb)
                heapq.heappush(open_set, (f[nb], nb))
\end{lstlisting}

